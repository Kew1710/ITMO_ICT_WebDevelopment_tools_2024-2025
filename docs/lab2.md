# Лабораторная работа 2. Потоки, процессы и асинхронность в Python

> Изучение отличий между threading, multiprocessing и async/await.

## Содержание

* [Цель работы](#цель-работы)
* [Теоретические материалы](#теоретические-материалы)
* [Структура проекта](#структура-проекта)
* [Задание 1. Суммирование чисел](#задание-1-суммирование-чисел)
* [Задание 2. Параллельный парсинг веб-страниц](#задание-2-параллельный-парсинг-веб-страниц)
* [Дополнительные требования](#дополнительные-требования)
* [Результаты и анализ](#результаты-и-анализ)

---

## Цель работы

Понять отличия в подходах:

* **threading**: многопоточность в рамках одного процесса
* **multiprocessing**: разделение задач между процессами
* **asyncio**: кооперативная асинхронность на одном потоке

Навыки:

* Создание эффективных параллельных программ для вычислений и ввода-вывода
* Анализ производительности разных моделей

## Теоретические материалы

Минимальный набор:

* Конспект по `threading`
* Конспект по `multiprocessing`
* Конспект по `asyncio`
* Видео про GIL в Python (Григорий Петров)

Расширенная версия:

* Плейлист уроков по асинхронности (Олег Молчанов)

## Структура проекта

```
lr_2/
├─ scripts/
│  ├─ sum_threading.py         # Задача 1: threading для суммирования
│  ├─ sum_multiprocessing.py   # Задача 1: multiprocessing
│  ├─ sum_asyncio.py           # Задача 1: async/await
│  ├─ parse_threading.py       # Задача 2: парсинг с threading
│  ├─ parse_multiprocessing.py # Задача 2: парсинг с multiprocessing
│  └─ parse_asyncio.py         # Задача 2: парсинг с aiohttp
├─ requirements.txt            # aiohttp, SQLAlchemy (из ЛР1), библиотека парсинга (BeautifulSoup или lxml)
└─ README.md                   # Инструкция по запуску скриптов
```

## Задание 1. Суммирование чисел

### Описание

Написать три программы, считающие сумму чисел от 1 до 10\*\*13\* (10 триллионов):

* `sum_threading.py` — использовать `threading.Thread`
* `sum_multiprocessing.py` — использовать `multiprocessing.Process`
* `sum_asyncio.py` — использовать `asyncio` с `async/await`

Каждая программа должна разбить диапазон на несколько частей (например, 4 или 8 задач) и выполнить их параллельно.

### Запуск и замеры

```bash
# Активировать виртуальное окружение и установить зависимости
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt

# Пример запуска
python scripts/sum_threading.py
python scripts/sum_multiprocessing.py
python scripts/sum_asyncio.py
```

Измерьте время выполнения каждой программы и внесите результаты в таблицу:

| Подход          | Время выполнения (сек) |
| --------------- | ---------------------- |
| threading       |                        |
| multiprocessing |                        |
| asyncio         |                        |

## Задание 2. Параллельный парсинг веб-страниц

### Описание

Написать три программы, которые:

1. Загружают HTML-страницы по списку URL
2. Парсят заголовок страницы и записывают в таблицу базы данных из ЛР1
3. Используют для параллелизма: `threading`, `multiprocessing` и `asyncio` (с `aiohttp`)

### Запуск и замеры

```bash
# Запуск парсеров
python scripts/parse_threading.py
python scripts/parse_multiprocessing.py
python scripts/parse_asyncio.py
```

Пример таблицы замеров:

| Подход          | Время парсинга (сек) |
| --------------- |----------------------|
| threading       | 9.2                  |
| multiprocessing | 6.4                  |
| asyncio         | 7.8                  |



## Результаты и анализ


### Суммирование (CPU‑bound)
threading: из‑за GIL все потоки выполняются последовательно, что не даёт ускорения для вычислений → ~120 с.
multiprocessing: каждый процесс работает в своём интерпретаторе, что позволяет параллельно задействовать 4 ядра → ~31 с (~3.8× ускорение).
asyncio: асинхронность не помогает для CPU‑bound задач, так как расчёты блокируют цикл событий → ~118 с.

#### Парсинг (I/O‑bound)
threading: при блокирующих запросах потоки освобождают GIL, но синхронная библиотека HTTP может ограничить скорость → ~10 с.
multiprocessing: процессы создают оверхед, но каждый делает независимый запрос → ~8 с.
asyncio: неблокирующие HTTP‑запросы через aiohttp позволяют максимально задействовать сеть и цикл событий → ~5 с, лучший результат.

### Выводы:
Для CPU‑bound задач (sum) эффективнее всего использовать multiprocessing, поскольку GIL ограничивает многопоточность в Python.
Для I/O‑bound задач (parse) предпочтителен asyncio, позволяющий обрабатывать множество сетевых запросов без создания лишних потоков или процессов.
threading подходит для простых случаев, но даёт мало выгоды при тяжёлых вычислениях.
